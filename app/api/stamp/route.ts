// Ensure this route is built and executed on the Node.js runtime (NOT Edge)
export const runtime = 'nodejs';

import { NextRequest, NextResponse } from 'next/server';
// (intentionally no static import for the worker)
import { auth } from '@/lib/auth';
import {
  logsTable,
  machinesTable,
  sitesTable,
  withRetry,
} from '@/lib/airtable';
import { findNearestSiteDetailed } from '@/lib/geo';
import { LOGS_ALLOWED_FIELDS, filterFields } from '@/lib/airtableSchema';
import { LogFields } from '@/types';
import { validateStampRequest } from './validator';
import { logger } from '@/lib/logger';

type SwitchIntentBody = {
  intent: 'switch';
  toMachineId?: unknown;
};

type AuthenticatedUser = {
  id: string;
  name?: string | null;
};

function isSwitchIntentBody(payload: unknown): payload is SwitchIntentBody {
  return (
    typeof payload === 'object' &&
    payload !== null &&
    (payload as { intent?: unknown }).intent === 'switch'
  );
}

function normalizeMachineId(value: unknown): string {
  return typeof value === 'string' ? value.trim() : '';
}

function formatDateJST(date: Date): string {
  return new Intl.DateTimeFormat('ja-JP', {
    timeZone: 'Asia/Tokyo',
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
  })
    .format(date)
    .replace(/\//g, '-');
}

async function createOutLogWithFallback(
  fields: Partial<LogFields> & { autoGenerated?: boolean },
): Promise<void> {
  const sanitized = Object.fromEntries(
    Object.entries(fields).filter(([, value]) => value !== undefined),
  ) as Partial<LogFields> & { autoGenerated?: boolean };

  try {
    await withRetry(() => logsTable.create([{ fields: sanitized }], { typecast: true }));
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    if (
      message.includes('Unknown field') ||
      message.includes('UNKNOWN_FIELD_NAME') ||
      message.includes('INVALID_REQUEST_UNKNOWN')
    ) {
      const fallback = { ...sanitized };
      delete (fallback as { autoGenerated?: boolean }).autoGenerated;
      logger.warn('stamp auto-switch fallback without autoGenerated field', {
        reason: message,
      });
      await withRetry(() => logsTable.create([{ fields: fallback }], { typecast: true }));
      return;
    }
    throw error;
  }
}

async function handleSwitchIntent(
  body: SwitchIntentBody,
  user: AuthenticatedUser,
): Promise<NextResponse> {
  const userRecordId = user.id;
  const toMachineId = normalizeMachineId(body.toMachineId);

  if (!toMachineId) {
    logger.info('stamp auto-switch skipped: missing destination machineId', {
      userId: userRecordId,
    });
    return NextResponse.json(
      { switched: false, reason: 'no-toMachineId' },
      { status: 400 },
    );
  }

  const userFormula = `FIND("${userRecordId}", ARRAYJOIN({user})) > 0`;

  try {
    const latestRecords = await withRetry(() =>
      logsTable
        .select({
          filterByFormula: userFormula,
          sort: [{ field: 'timestamp', direction: 'desc' }],
          maxRecords: 1,
        })
        .firstPage(),
    );
    const latestLog = latestRecords[0];

    if (!latestLog || latestLog.fields.type !== 'IN') {
      logger.info('stamp auto-switch skipped: no open IN', {
        userId: userRecordId,
        toMachineId,
      });
      return NextResponse.json(
        { switched: false, reason: 'no-open-in' },
        { status: 200 },
      );
    }

    const machineLinks = Array.isArray(latestLog.fields.machine)
      ? [...latestLog.fields.machine]
      : [];
    const machineRecordId = machineLinks[0];

    if (!machineRecordId) {
      logger.warn('stamp auto-switch skipped: machine link missing on IN log', {
        userId: userRecordId,
        inLogId: latestLog.id,
      });
      return NextResponse.json(
        { switched: false, reason: 'in-missing-machine' },
        { status: 200 },
      );
    }

    const machineRecord = await withRetry(() => machinesTable.find(machineRecordId));
    const fromMachineId = normalizeMachineId(machineRecord?.fields?.machineid);

    if (!fromMachineId) {
      logger.warn('stamp auto-switch skipped: machineId missing on linked machine', {
        userId: userRecordId,
        inLogId: latestLog.id,
      });
      return NextResponse.json(
        { switched: false, reason: 'in-missing-machine' },
        { status: 200 },
      );
    }

    if (fromMachineId.toLowerCase() === toMachineId.toLowerCase()) {
      logger.info('stamp auto-switch skipped: same machine tapped', {
        userId: userRecordId,
        machineId: fromMachineId,
      });
      return NextResponse.json(
        { switched: false, reason: 'same-machine' },
        { status: 200 },
      );
    }

    const existingOuts = await withRetry(() =>
      logsTable
        .select({
          filterByFormula: `AND(${userFormula}, {type} = 'OUT', {timestamp} >= '${latestLog.fields.timestamp}')`,
          maxRecords: 1,
        })
        .firstPage(),
    );

    if (existingOuts.length > 0) {
      logger.info('stamp auto-switch skipped: already closed after IN', {
        userId: userRecordId,
        fromMachineId,
        toMachineId,
      });
      return NextResponse.json(
        { switched: false, reason: 'already-closed' },
        { status: 200 },
      );
    }

    const currentLatestRecords = await withRetry(() =>
      logsTable
        .select({
          filterByFormula: userFormula,
          sort: [{ field: 'timestamp', direction: 'desc' }],
          maxRecords: 1,
        })
        .firstPage(),
    );
    const currentLatest = currentLatestRecords[0];

    if (!currentLatest || currentLatest.id !== latestLog.id) {
      logger.info('stamp auto-switch skipped: IN log replaced before switch', {
        userId: userRecordId,
        fromMachineId,
        toMachineId,
      });
      return NextResponse.json(
        { switched: false, reason: 'already-closed' },
        { status: 200 },
      );
    }

    const now = new Date();
    const timestamp = now.toISOString();
    const date = formatDateJST(now);

    const userLinks =
      Array.isArray(latestLog.fields.user) && latestLog.fields.user.length > 0
        ? [...latestLog.fields.user]
        : [userRecordId];
    const siteName =
      typeof latestLog.fields.siteName === 'string' ? latestLog.fields.siteName : undefined;
    const workDescription =
      typeof latestLog.fields.workDescription === 'string'
        ? latestLog.fields.workDescription
        : undefined;

    await createOutLogWithFallback({
      type: 'OUT',
      timestamp,
      date,
      user: userLinks,
      machine: machineLinks as readonly string[],
      siteName,
      workDescription,
      autoGenerated: true,
    });

    logger.info('stamp auto-switch success', {
      userId: userRecordId,
      fromMachineId,
      toMachineId,
    });
    return NextResponse.json({ switched: true }, { status: 200 });
  } catch (error) {
    logger.error('stamp auto-switch failed', {
      userId: userRecordId,
      toMachineId,
      error,
    });
    return NextResponse.json({ switched: false, reason: 'error' }, { status: 500 });
  }
}

function errorResponse(
  code: string,
  reason: string,
  hint: string,
  status: number,
) {
  return NextResponse.json({ ok: false, code, reason, hint }, { status });
}

export async function POST(req: NextRequest) {
  const session = await auth();
  if (!session?.user?.id) {
    return errorResponse(
      'UNAUTHORIZED',
      'Authentication required',
      'Sign in and retry',
      401,
    );
  }

  let rawBody: unknown;
  try {
    rawBody = await req.json();
  } catch (error) {
    logger.warn('stamp request parse failed', { error });
    return errorResponse('INVALID_BODY', 'Invalid request body', 'Malformed JSON', 400);
  }

  if (isSwitchIntentBody(rawBody)) {
    return handleSwitchIntent(rawBody, { id: session.user.id, name: session.user.name });
  }

  const parsed = validateStampRequest(rawBody);
  if (!parsed.success) {
    return errorResponse('INVALID_BODY', 'Invalid request body', parsed.hint, 400);
  }

  const {
    machineId,
    workDescription,
    lat,
    lon,
    accuracy,
    type,
  } = parsed.data;

  try {
    const machineRecords = await machinesTable
      .select({
        filterByFormula: `{machineid} = '${machineId}'`,
        maxRecords: 1,
      })
      .firstPage();

    if (machineRecords.length === 0 || !machineRecords[0].fields.active) {
      return errorResponse(
        'INVALID_MACHINE',
        'Invalid or inactive machine ID',
        'Check machineId',
        400,
      );
    }
    const machineRecordId = machineRecords[0].id;

    const activeSites = await sitesTable.select({ filterByFormula: '{active} = 1' }).all();
    logger.info('stamp active sites summary', {
      count: activeSites.length,
      hasAcoru: activeSites.some((s) => s.fields.name === 'Acoru合同会社'),
    });
    const { site: nearestSite, method: decisionMethod, nearestDistanceM } =
      findNearestSiteDetailed(lat, lon, activeSites);

    const now = new Date();
    const timestamp = now.toISOString();
    const dateJST = new Intl.DateTimeFormat('ja-JP', {
      timeZone: 'Asia/Tokyo',
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
    }).format(now).replace(/\//g, '-');

    const candidate = {
      timestamp,
      date: dateJST,
      user: [session.user.id], // AirtableのUsersテーブルのレコードID
      machine: [machineRecordId],
      siteName: nearestSite?.fields.name ?? null,
      lat,
      lon,
      accuracy,
      workDescription,
      type,
    };
    const fields = filterFields(candidate, LOGS_ALLOWED_FIELDS) as Partial<LogFields>;
    if (!fields.siteName && nearestSite?.fields?.name) {
      fields.siteName = nearestSite.fields.name;
    }
    const clientName =
      typeof nearestSite?.fields?.client === 'string'
        ? nearestSite.fields.client.trim()
        : undefined;
    if (clientName) {
      fields.clientName = clientName;
    }
    if (!fields.timestamp) {
      fields.timestamp = timestamp;
    }

    const createdRecords = await withRetry(() =>
      logsTable.create([{ fields }], { typecast: true })
    );
    const created = createdRecords[0];

    if (created) {
      logger.info('stamp record created', {
        userId: session.user.id,
        recordId: created.id,
        type,
      });
    }

    return NextResponse.json(
      {
        decidedSiteId: nearestSite?.fields.siteId ?? null,
        decidedSiteName: nearestSite?.fields.name ?? null,
        decision_method: decisionMethod,
        nearest_distance_m: nearestDistanceM ?? null,
        accuracy,
      },
      { status: 200 },
    );
  } catch (error) {
    logger.error('Failed to record stamp', error);
    return errorResponse(
      'INTERNAL_ERROR',
      'Internal Server Error',
      'Retry later',
      500,
    );
  }
}
