// Ensure this route is built and executed on the Node.js runtime (NOT Edge)
export const runtime = 'nodejs';

import { NextRequest, NextResponse } from 'next/server';
import type { Record as AirtableRecord } from 'airtable';
// (intentionally no static import for the worker)
import { auth } from '@/lib/auth';
import {
  logsTable,
  machinesTable,
  sitesTable,
  withRetry,
} from '@/lib/airtable';
import { findNearestSiteDetailed } from '@/lib/geo';
import { LOGS_ALLOWED_FIELDS, filterFields } from '@/lib/airtableSchema';
import { LogFields } from '@/types';
import { validateStampRequest } from './validator';
import { logger } from '@/lib/logger';

type SwitchIntentBody = {
  intent: 'switch';
  toMachineId?: unknown;
};

type AuthenticatedUser = {
  id: string;
  name?: string | null;
};

function isSwitchIntentBody(payload: unknown): payload is SwitchIntentBody {
  return (
    typeof payload === 'object' &&
    payload !== null &&
    (payload as { intent?: unknown }).intent === 'switch'
  );
}

function normalizeMachineId(value: unknown): string {
  if (value == null) {
    return '';
  }
  return String(value).trim();
}

function formatDateJST(date: Date): string {
  return new Intl.DateTimeFormat('ja-JP', {
    timeZone: 'Asia/Tokyo',
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
  })
    .format(date)
    .replace(/\//g, '-');
}

type LogRecord = AirtableRecord<LogFields>;

function buildUserFormula(userRecordId: string): string {
  return `FIND("${userRecordId}", ARRAYJOIN({user})) > 0`;
}

async function findLatestInLog(userFormula: string): Promise<LogRecord | null> {
  const records = await withRetry(() =>
    logsTable
      .select({
        filterByFormula: `AND(${userFormula}, {type} = 'IN')`,
        sort: [{ field: 'timestamp', direction: 'desc' }],
        maxRecords: 1,
      })
      .firstPage(),
  );
  return records[0] ?? null;
}

async function hasOutSince(userFormula: string, timestamp: string): Promise<boolean> {
  const records = await withRetry(() =>
    logsTable
      .select({
        filterByFormula: `AND(${userFormula}, {type} = 'OUT', {timestamp} >= '${timestamp}')`,
        maxRecords: 1,
      })
      .firstPage(),
  );
  return records.length > 0;
}

async function createOutLogWithFallback(
  fields: Partial<LogFields> & { autoGenerated?: boolean },
): Promise<void> {
  const sanitized = Object.fromEntries(
    Object.entries(fields).filter(([, value]) => value !== undefined),
  ) as Partial<LogFields> & { autoGenerated?: boolean };

  try {
    await withRetry(() => logsTable.create([{ fields: sanitized }], { typecast: true }));
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    if (
      message.includes('Unknown field') ||
      message.includes('UNKNOWN_FIELD_NAME') ||
      message.includes('INVALID_REQUEST_UNKNOWN')
    ) {
      const fallback = { ...sanitized };
      delete (fallback as { autoGenerated?: boolean }).autoGenerated;
      logger.warn('stamp auto-switch fallback without autoGenerated field', {
        reason: message,
      });
      await withRetry(() => logsTable.create([{ fields: fallback }], { typecast: true }));
      return;
    }
    throw error;
  }
}

async function handleSwitchIntent(
  body: SwitchIntentBody,
  user: AuthenticatedUser,
): Promise<NextResponse> {
  const userRecordId = user.id;
  const toMachineId = normalizeMachineId(body.toMachineId);

  if (!toMachineId) {
    logger.info('stamp auto-switch skipped: missing destination machineId', {
      userId: userRecordId,
    });
    return NextResponse.json(
      { switched: false, reason: 'no-toMachineId' },
      { status: 400 },
    );
  }

  const userFormula = buildUserFormula(userRecordId);

  try {
    const latestLog = await findLatestInLog(userFormula);

    if (!latestLog) {
      logger.info('stamp auto-switch skipped: no open IN', {
        userId: userRecordId,
        toMachineId,
      });
      return NextResponse.json(
        { switched: false, reason: 'no-open-in' },
        { status: 200 },
      );
    }

    const inTimestamp =
      typeof latestLog.fields.timestamp === 'string' ? latestLog.fields.timestamp : '';
    if (!inTimestamp) {
      logger.warn('stamp auto-switch skipped: IN log missing timestamp', {
        userId: userRecordId,
        inLogId: latestLog.id,
      });
      return NextResponse.json(
        { switched: false, reason: 'in-missing-timestamp' },
        { status: 200 },
      );
    }

    const machineLinks = Array.isArray(latestLog.fields.machine)
      ? [...latestLog.fields.machine]
      : [];
    const machineRecordId = machineLinks[0];

    if (!machineRecordId) {
      logger.warn('stamp auto-switch skipped: machine link missing on IN log', {
        userId: userRecordId,
        inLogId: latestLog.id,
      });
      return NextResponse.json(
        { switched: false, reason: 'in-missing-machine' },
        { status: 200 },
      );
    }

    const lookupMachineId = normalizeMachineId(
      (latestLog.fields as Record<string, unknown>)['machineId (from machine)'],
    );
    let fromMachineId = lookupMachineId;

    if (!fromMachineId) {
      const machineRecord = await withRetry(() => machinesTable.find(machineRecordId));
      fromMachineId = normalizeMachineId(machineRecord?.fields?.machineid);
    }

    if (!fromMachineId) {
      logger.warn('stamp auto-switch skipped: machineId missing on linked machine', {
        userId: userRecordId,
        inLogId: latestLog.id,
      });
      return NextResponse.json(
        { switched: false, reason: 'in-missing-machine' },
        { status: 200 },
      );
    }

    if (fromMachineId.toLowerCase() === toMachineId.toLowerCase()) {
      logger.info('stamp auto-switch skipped: same machine tapped', {
        userId: userRecordId,
        machineId: fromMachineId,
      });
      return NextResponse.json(
        { switched: false, reason: 'same-machine' },
        { status: 200 },
      );
    }

    const alreadyClosed = await hasOutSince(userFormula, inTimestamp);

    if (alreadyClosed) {
      logger.info('stamp auto-switch skipped: already closed after IN', {
        userId: userRecordId,
        fromMachineId,
        toMachineId,
      });
      return NextResponse.json(
        { switched: false, reason: 'already-closed' },
        { status: 200 },
      );
    }

    const currentLatest = await findLatestInLog(userFormula);

    if (!currentLatest || currentLatest.id !== latestLog.id) {
      logger.info('stamp auto-switch skipped: IN log replaced before switch', {
        userId: userRecordId,
        fromMachineId,
        toMachineId,
      });
      return NextResponse.json(
        { switched: false, reason: 'already-closed' },
        { status: 200 },
      );
    }

    const now = new Date();
    const timestamp = now.toISOString();
    const date = formatDateJST(now);

    const userLinks =
      Array.isArray(latestLog.fields.user) && latestLog.fields.user.length > 0
        ? [...latestLog.fields.user]
        : [userRecordId];
    const siteName =
      typeof latestLog.fields.siteName === 'string' ? latestLog.fields.siteName : undefined;
    const workDescription =
      typeof latestLog.fields.workDescription === 'string'
        ? latestLog.fields.workDescription
        : undefined;

    await createOutLogWithFallback({
      type: 'OUT',
      timestamp,
      date,
      user: userLinks,
      machine: machineLinks,
      siteName,
      workDescription,
      autoGenerated: true,
    });

    logger.info('stamp auto-switch success', {
      userId: userRecordId,
      fromMachineId,
      toMachineId,
    });
    return NextResponse.json({ switched: true }, { status: 200 });
  } catch (error) {
    logger.error('stamp auto-switch failed', {
      userId: userRecordId,
      toMachineId,
      error,
    });
    return NextResponse.json({ switched: false, reason: 'error' }, { status: 500 });
  }
}

function errorResponse(
  code: string,
  reason: string,
  hint: string,
  status: number,
) {
  return NextResponse.json({ ok: false, code, reason, hint }, { status });
}

export async function POST(req: NextRequest) {
  const session = await auth();
  if (!session?.user?.id) {
    return errorResponse(
      'UNAUTHORIZED',
      'Authentication required',
      'Sign in and retry',
      401,
    );
  }

  let rawBody: unknown;
  try {
    rawBody = await req.json();
  } catch (error) {
    logger.warn('stamp request parse failed', { error });
    return errorResponse('INVALID_BODY', 'Invalid request body', 'Malformed JSON', 400);
  }

  if (isSwitchIntentBody(rawBody)) {
    return handleSwitchIntent(rawBody, { id: session.user.id, name: session.user.name });
  }

  const parsed = validateStampRequest(rawBody);
  if (!parsed.success) {
    return errorResponse('INVALID_BODY', 'Invalid request body', parsed.hint, 400);
  }

  const {
    machineId,
    workDescription,
    lat,
    lon,
    accuracy,
    type,
  } = parsed.data;

  try {
    if (type === 'OUT') {
      const userRecordId = session.user.id;
      const userFormula = buildUserFormula(userRecordId);
      const latestIn = await findLatestInLog(userFormula);

      if (!latestIn) {
        return errorResponse(
          'NO_OPEN_IN',
          'No active IN log found',
          'Refresh the page and retry',
          400,
        );
      }

      const inTimestamp =
        typeof latestIn.fields.timestamp === 'string' ? latestIn.fields.timestamp : '';
      if (!inTimestamp) {
        return errorResponse(
          'IN_MISSING_TIMESTAMP',
          'Active IN log is missing timestamp',
          'Contact administrator',
          500,
        );
      }

      const alreadyClosed = await hasOutSince(userFormula, inTimestamp);
      if (alreadyClosed) {
        return errorResponse(
          'ALREADY_CLOSED',
          'The IN log has already been closed',
          'Reload and confirm status',
          409,
        );
      }

      const currentLatest = await findLatestInLog(userFormula);
      if (!currentLatest || currentLatest.id !== latestIn.id) {
        return errorResponse(
          'IN_CHANGED',
          'A newer IN log was created',
          'Reload and retry',
          409,
        );
      }

      const machineLinks = Array.isArray(latestIn.fields.machine)
        ? [...latestIn.fields.machine]
        : [];
      if (machineLinks.length === 0) {
        return errorResponse(
          'IN_MISSING_MACHINE',
          'Active IN log is missing machine link',
          'Contact administrator',
          500,
        );
      }

      const userLinks =
        Array.isArray(latestIn.fields.user) && latestIn.fields.user.length > 0
          ? [...latestIn.fields.user]
          : [userRecordId];
      const siteNameFromIn =
        typeof latestIn.fields.siteName === 'string' ? latestIn.fields.siteName : undefined;
      const workDescriptionFromIn =
        typeof latestIn.fields.workDescription === 'string'
          ? latestIn.fields.workDescription
          : undefined;
      const clientNameFromIn =
        typeof (latestIn.fields as Record<string, unknown>).clientName === 'string'
          ? String((latestIn.fields as Record<string, unknown>).clientName)
          : undefined;

      const now = new Date();
      const timestamp = now.toISOString();
      const dateJST = formatDateJST(now);
      const accuracyValue = typeof accuracy === 'number' ? accuracy : undefined;

      const candidate = filterFields(
        {
          type: 'OUT',
          timestamp,
          date: dateJST,
          user: userLinks,
          machine: machineLinks,
          siteName: siteNameFromIn,
          workDescription: workDescriptionFromIn,
          clientName: clientNameFromIn,
          lat,
          lon,
          accuracy: accuracyValue,
        },
        LOGS_ALLOWED_FIELDS,
      ) as Partial<LogFields>;

      const createdRecords = await withRetry(() =>
        logsTable.create([{ fields: candidate }], { typecast: true }),
      );
      const created = createdRecords[0];

      if (created) {
        logger.info('stamp manual OUT created', {
          userId: session.user.id,
          recordId: created.id,
        });
      }

      return NextResponse.json(
        {
          decidedSiteId: null,
          decidedSiteName: siteNameFromIn ?? null,
          decision_method: 'inherit',
          nearest_distance_m: null,
          accuracy: typeof accuracy === 'number' ? accuracy : null,
        },
        { status: 200 },
      );
    }

    const machineRecords = await withRetry(() =>
      machinesTable
        .select({
          filterByFormula: `{machineid} = '${machineId}'`,
          maxRecords: 1,
        })
        .firstPage(),
    );

    if (machineRecords.length === 0 || !machineRecords[0].fields.active) {
      return errorResponse(
        'INVALID_MACHINE',
        'Invalid or inactive machine ID',
        'Check machineId',
        400,
      );
    }
    const machineRecordId = machineRecords[0].id;

    const activeSites = await sitesTable.select({ filterByFormula: '{active} = 1' }).all();
    logger.info('stamp active sites summary', {
      count: activeSites.length,
      hasAcoru: activeSites.some((s) => s.fields.name === 'Acoru合同会社'),
    });
    const { site: nearestSite, method: decisionMethod, nearestDistanceM } =
      findNearestSiteDetailed(lat, lon, activeSites);

    const now = new Date();
    const timestamp = now.toISOString();
    const dateJST = formatDateJST(now);

    const candidate = {
      timestamp,
      date: dateJST,
      user: [session.user.id], // AirtableのUsersテーブルのレコードID
      machine: [machineRecordId],
      siteName: nearestSite?.fields.name ?? null,
      lat,
      lon,
      accuracy,
      workDescription,
      type,
    };
    const fields = filterFields(candidate, LOGS_ALLOWED_FIELDS) as Partial<LogFields>;
    if (!fields.siteName && nearestSite?.fields?.name) {
      fields.siteName = nearestSite.fields.name;
    }
    const clientName =
      typeof nearestSite?.fields?.client === 'string'
        ? nearestSite.fields.client.trim()
        : undefined;
    if (clientName) {
      fields.clientName = clientName;
    }
    if (!fields.timestamp) {
      fields.timestamp = timestamp;
    }

    const createdRecords = await withRetry(() =>
      logsTable.create([{ fields }], { typecast: true })
    );
    const created = createdRecords[0];

    if (created) {
      logger.info('stamp record created', {
        userId: session.user.id,
        recordId: created.id,
        type,
      });
    }

    return NextResponse.json(
      {
        decidedSiteId: nearestSite?.fields.siteId ?? null,
        decidedSiteName: nearestSite?.fields.name ?? null,
        decision_method: decisionMethod,
        nearest_distance_m: nearestDistanceM ?? null,
        accuracy,
      },
      { status: 200 },
    );
  } catch (error) {
    logger.error('Failed to record stamp', error);
    return errorResponse(
      'INTERNAL_ERROR',
      'Internal Server Error',
      'Retry later',
      500,
    );
  }
}
