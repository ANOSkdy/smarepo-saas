/* eslint-disable @typescript-eslint/no-explicit-any */
// Lightweight Sessions data-access + aggregations (Airtable REST)
// Sole source for dashboard/reports/sites with minimal UI changes.
// Schema (CSV verified): sessionId,user,inLog,outLog,start,end,siteName,workDescription,
// machineId,machine,machineName,autoGenerated,date,durationMin,status,uniqueKey

import { applyTimeCalcV2FromMinutes } from '@/src/lib/timecalc';
import { findUserByAnyKey, getUsersMap, type UserLookupValue } from '@/lib/airtable/users';

type ISODate = string; // "YYYY-MM-DD"
type Status = 'open' | 'close' | string;

export type SessionRecord = {
  id: string; // airtable rec id
  sessionId?: string;
  user?: number | string;
  inLog?: string;
  outLog?: string;
  start?: string;
  end?: string;
  siteName?: string;
  workDescription?: string;
  machineId?: number | string;
  machine?: number | string;
  machineName?: string;
  autoGenerated?: any;
  date?: ISODate;
  durationMin?: number;
  status?: Status;
  uniqueKey?: string;
};

export type SessionsQuery = {
  dateFrom?: ISODate;
  dateTo?: ISODate;
  date?: ISODate;
  status?: Status;
  user?: string | number;
  siteName?: string;
  machineId?: string | number;
  workDescription?: string;
  maxRecords?: number;
  pageSize?: number;
  sortBy?: { field: keyof SessionRecord; direction?: 'asc' | 'desc' }[];
  filterFormula?: string;
};

const API = 'https://api.airtable.com/v0';
const API_KEY = process.env.AIRTABLE_API_KEY as string | undefined;
const BASE_ID = process.env.AIRTABLE_BASE_ID as string | undefined;
const TABLE = (process.env.AIRTABLE_TABLE_SESSIONS ?? 'Sessions') as string;

function assertEnv() {
  if (!API_KEY || !BASE_ID || !TABLE) {
    throw new Error('Airtable env missing: require AIRTABLE_API_KEY / AIRTABLE_BASE_ID / AIRTABLE_TABLE_SESSIONS');
  }
}

function esc(v: string) {
  return v.replace(/'/g, "\\'");
}

function buildFilterByFormula(q: SessionsQuery): string | undefined {
  if (q.filterFormula) {
    return q.filterFormula;
  }
  const conds: string[] = [];
  // Prefer simple string/range compares – robust for Date field or "YYYY-MM-DD" string.
  if (q.date) conds.push(`{date}='${esc(q.date)}'`);
  if (q.dateFrom) conds.push(`{date}>='${esc(q.dateFrom)}'`);
  if (q.dateTo) conds.push(`{date}<='${esc(q.dateTo)}'`);
  if (q.status) conds.push(`{status}='${esc(String(q.status))}'`);
  if (q.user !== undefined) conds.push(`{user}='${esc(String(q.user))}'`);
  if (q.siteName) conds.push(`{siteName}='${esc(q.siteName)}'`);
  if (q.machineId !== undefined) conds.push(`{machineId}='${esc(String(q.machineId))}'`);
  if (q.workDescription) conds.push(`{workDescription}='${esc(q.workDescription)}'`);
  if (!conds.length) return undefined;
  return conds.length === 1 ? conds[0] : `AND(${conds.join(',')})`;
}

type AirtableResp = {
  records: { id: string; fields: Record<string, any> }[];
  offset?: string;
};

export async function listSessions(q: SessionsQuery = {}): Promise<SessionRecord[]> {
  assertEnv();
  const params = new URLSearchParams();
  const f = buildFilterByFormula(q);
  if (f) params.set('filterByFormula', f);
  if (q.maxRecords) params.set('maxRecords', String(q.maxRecords));
  if (q.pageSize) params.set('pageSize', String(q.pageSize));
  if (q.sortBy?.length) {
    q.sortBy.forEach((s, i) => {
      params.set(`sort[${i}][field]`, String(s.field));
      if (s.direction) params.set(`sort[${i}][direction]`, s.direction);
    });
  }
  let url = `${API}/${BASE_ID}/${encodeURIComponent(TABLE)}?${params.toString()}`;
  const out: SessionRecord[] = [];
  // simple pagination
  while (true) {
    const res = await fetch(url, {
      headers: { Authorization: `Bearer ${API_KEY}` },
      cache: 'no-store',
    });
    if (!res.ok) {
      const t = await res.text().catch(() => '');
      throw new Error(`Airtable Sessions fetch failed: ${res.status} ${t}`);
    }
    const json: AirtableResp = await res.json();
    for (const r of json.records) {
      out.push({ id: r.id, ...(r.fields as any) });
    }
    if (!json.offset) break;
    url = `${API}/${BASE_ID}/${encodeURIComponent(TABLE)}?${params.toString()}&offset=${json.offset}`;
  }
  return out;
}

// ---------- Aggregations (minimal & UI-friendly) ----------
const minutesToHours = (m?: number) => (typeof m === 'number' ? m / 60 : 0);
const JST_OFFSET_MS = 9 * 60 * 60 * 1000;

function toText(value: unknown): string {
  if (typeof value === 'string') {
    return value.trim();
  }
  if (typeof value === 'number') {
    return String(value);
  }
  return '';
}

function parseDate(value: unknown): string | null {
  if (typeof value === 'string') {
    const trimmed = value.trim();
    if (/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) {
      return trimmed;
    }
  }
  return null;
}

function parseTimestamp(value: unknown): number | null {
  if (typeof value !== 'string') {
    return null;
  }
  const trimmed = value.trim();
  if (!trimmed) {
    return null;
  }
  const parsed = Date.parse(trimmed);
  return Number.isFinite(parsed) ? parsed : null;
}

function ensureDate(session: SessionRecord): string | null {
  return (
    parseDate(session.date)
    ?? (typeof session.start === 'string' && session.start.length >= 10 ? session.start.slice(0, 10) : null)
    ?? (typeof session.inLog === 'string' && session.inLog.length >= 10 ? session.inLog.slice(0, 10) : null)
  );
}

function formatJstTime(ms: number): string {
  const jst = new Date(ms + JST_OFFSET_MS);
  const hours = String(jst.getUTCHours()).padStart(2, '0');
  const minutes = String(jst.getUTCMinutes()).padStart(2, '0');
  return `${hours}:${minutes}`;
}

function formatJstIso(ms: number): string {
  const jst = new Date(ms + JST_OFFSET_MS);
  const year = jst.getUTCFullYear();
  const month = String(jst.getUTCMonth() + 1).padStart(2, '0');
  const day = String(jst.getUTCDate()).padStart(2, '0');
  const hour = String(jst.getUTCHours()).padStart(2, '0');
  const minute = String(jst.getUTCMinutes()).padStart(2, '0');
  const second = String(jst.getUTCSeconds()).padStart(2, '0');
  return `${year}-${month}-${day}T${hour}:${minute}:${second}+09:00`;
}

function resolveDurationMinutes(session: SessionRecord): number | null {
  if (typeof session.durationMin === 'number' && Number.isFinite(session.durationMin)) {
    return Math.max(0, session.durationMin);
  }
  if (session.durationMin !== undefined) {
    const parsed = Number(session.durationMin);
    if (Number.isFinite(parsed)) {
      return Math.max(0, parsed);
    }
  }
  const startMs = parseTimestamp(session.start);
  const endMs = parseTimestamp(session.end);
  if (startMs !== null && endMs !== null && endMs > startMs) {
    return Math.max(0, Math.round((endMs - startMs) / 60000));
  }
  return null;
}

function resolveClockInMs(session: SessionRecord): number | null {
  return parseTimestamp(session.start) ?? parseTimestamp(session.inLog) ?? null;
}

function resolveClockOutMs(session: SessionRecord, clockInMs: number | null): number | null {
  const direct = parseTimestamp(session.end) ?? parseTimestamp(session.outLog);
  if (direct !== null) {
    return direct;
  }
  if (clockInMs !== null) {
    const duration = resolveDurationMinutes(session);
    if (duration !== null) {
      return clockInMs + duration * 60000;
    }
  }
  return null;
}

function normalizeStatus(session: SessionRecord): string {
  return typeof session.status === 'string' ? session.status.trim().toLowerCase() : '';
}

async function getCachedUsersMap(
  cache: Map<string, Map<string, UserLookupValue>>,
  cacheKey: string,
): Promise<Map<string, UserLookupValue>> {
  const existing = cache.get(cacheKey);
  if (existing) {
    return existing;
  }
  const map = await getUsersMap();
  cache.set(cacheKey, map);
  return map;
}

const usersMapCache = new Map<string, Map<string, UserLookupValue>>();

function resolveUserInfo(session: SessionRecord, usersMap: Map<string, UserLookupValue>) {
  const raw = session.user;
  const fallback = toText(raw);
  const matched = findUserByAnyKey(usersMap, raw) ?? (fallback ? findUserByAnyKey(usersMap, fallback) : undefined);
  return {
    recordId: matched?.recordId ?? null,
    name: matched?.name ?? (fallback || '未登録ユーザー'),
  };
}

export type DashboardAgg = {
  totalHours: number;
  hoursBySite: Record<string, number>;
  hoursByMachine: Record<string, number>;
  hoursByWork: Record<string, number>;
  openCount: number;
};

export async function getDashboardAgg(
  opts: { date?: ISODate; week?: { from: ISODate; to: ISODate }; month?: { from: ISODate; to: ISODate } } = {}
): Promise<DashboardAgg> {
  // prefer "close" sessions for totals; open sessions only for count
  const range = opts.date
    ? { date: opts.date }
    : opts.week
    ? { dateFrom: opts.week.from, dateTo: opts.week.to }
    : opts.month
    ? { dateFrom: opts.month.from, dateTo: opts.month.to }
    : {};
  const [closed, open] = await Promise.all([
    listSessions({ ...range, status: 'close', pageSize: 100 }),
    listSessions({ ...range, status: 'open', pageSize: 100 }),
  ]);
  const totalHours = closed.reduce((sum, record) => sum + minutesToHours(record.durationMin), 0);
  const hoursBy = (key: keyof SessionRecord) =>
    closed.reduce<Record<string, number>>((acc, record) => {
      const k = String((record as any)[key] ?? '');
      if (!k) return acc;
      acc[k] = (acc[k] ?? 0) + minutesToHours(record.durationMin);
      return acc;
    }, {});
  return {
    totalHours,
    hoursBySite: hoursBy('siteName'),
    hoursByMachine: hoursBy('machineId'),
    hoursByWork: hoursBy('workDescription'),
    openCount: open.length,
  };
}

export type GenericGroupAgg = { key: string; hours: number; count: number };

export async function getReportsAgg(opts: {
  from: ISODate;
  to: ISODate;
  user?: string | number;
  siteName?: string;
  machineId?: string | number;
  workDescription?: string;
}): Promise<{
  byDate: GenericGroupAgg[];
  byUser: GenericGroupAgg[];
  bySite: GenericGroupAgg[];
  byMachine: GenericGroupAgg[];
  byWork: GenericGroupAgg[];
}> {
  const rows = await listSessions({
    dateFrom: opts.from,
    dateTo: opts.to,
    status: 'close',
    user: opts.user,
    siteName: opts.siteName,
    machineId: opts.machineId,
    workDescription: opts.workDescription,
    pageSize: 100,
  });
  const sumBy = (key: keyof SessionRecord) => {
    const map = new Map<string, { hours: number; count: number }>();
    for (const record of rows) {
      const groupKey = String((record as any)[key] ?? '');
      const entry = map.get(groupKey) ?? { hours: 0, count: 0 };
      entry.hours += minutesToHours(record.durationMin);
      entry.count += 1;
      map.set(groupKey, entry);
    }
    return [...map.entries()].map(([groupKey, value]) => ({ key: groupKey, hours: value.hours, count: value.count }));
  };
  return {
    byDate: sumBy('date'),
    byUser: sumBy('user'),
    bySite: sumBy('siteName'),
    byMachine: sumBy('machineId'),
    byWork: sumBy('workDescription'),
  };
}

export async function getSiteAgg(opts: { siteName: string; date?: ISODate; from?: ISODate; to?: ISODate }) {
  const rows = await listSessions({
    siteName: opts.siteName,
    ...(opts.date ? { date: opts.date } : {}),
    ...(opts.from || opts.to ? { dateFrom: opts.from, dateTo: opts.to } : {}),
    status: 'close',
    pageSize: 100,
  });
  const totalHours = rows.reduce((sum, record) => sum + minutesToHours(record.durationMin), 0);
  const byUser = rows.reduce<Record<string, number>>((acc, record) => {
    const key = String(record.user ?? '');
    if (!key) return acc;
    acc[key] = (acc[key] ?? 0) + minutesToHours(record.durationMin);
    return acc;
  }, {});
  const byMachine = rows.reduce<Record<string, number>>((acc, record) => {
    const key = String(record.machineId ?? '');
    if (!key) return acc;
    acc[key] = (acc[key] ?? 0) + minutesToHours(record.durationMin);
    return acc;
  }, {});
  const byWork = rows.reduce<Record<string, number>>((acc, record) => {
    const key = String(record.workDescription ?? '');
    if (!key) return acc;
    acc[key] = (acc[key] ?? 0) + minutesToHours(record.durationMin);
    return acc;
  }, {});
  return { totalHours, byUser, byMachine, byWork, rows };
}

// Adapter helpers to keep old prop names if UI expects "workType"
export function mapWorkTypeCompat<T extends { workDescription?: string }>(row: T): T & { workType?: string } {
  return Object.assign({}, row as any, { workType: (row as any).workDescription });
}

export type CalendarDaySummary = {
  date: string;
  sites: string[];
  punches: number;
  sessions: number;
  hours: number;
};

export async function getCalendarMonthSummary(
  opts: { year: number; month: number },
): Promise<{ year: number; month: number; days: CalendarDaySummary[] }> {
  const { year, month } = opts;
  if (!Number.isFinite(year) || !Number.isFinite(month)) {
    return { year, month, days: [] as CalendarDaySummary[] };
  }
  const monthText = String(month).padStart(2, '0');
  const startDate = `${year}-${monthText}-01`;
  const lastDay = new Date(Date.UTC(year, month, 0));
  const endDate = `${lastDay.getUTCFullYear()}-${String(lastDay.getUTCMonth() + 1).padStart(2, '0')}-${String(
    lastDay.getUTCDate(),
  ).padStart(2, '0')}`;

  const sessions = await listSessions({ dateFrom: startDate, dateTo: endDate, pageSize: 100 });

  const map = new Map<string, { sites: Set<string>; punches: number; sessions: number; minutes: number }>();
  for (const session of sessions) {
    const date = ensureDate(session);
    if (!date) {
      continue;
    }
    const bucket = map.get(date) ?? { sites: new Set<string>(), punches: 0, sessions: 0, minutes: 0 };
    const site = toText(session.siteName);
    if (site) {
      bucket.sites.add(site);
    }
    const status = normalizeStatus(session);
    if (status === 'close') {
      bucket.punches += 2;
      bucket.sessions += 1;
      const minutes = resolveDurationMinutes(session);
      if (minutes !== null) {
        bucket.minutes += minutes;
      }
    } else {
      bucket.punches += 1;
    }
    map.set(date, bucket);
  }

  const days: CalendarDaySummary[] = Array.from(map.entries())
    .map(([date, value]) => ({
      date,
      sites: Array.from(value.sites),
      punches: value.punches,
      sessions: value.sessions,
      hours: applyTimeCalcV2FromMinutes(value.minutes).hours,
    }))
    .sort((a, b) => a.date.localeCompare(b.date));

  return { year, month, days };
}

export type DaySessionDetail = {
  userId: string | null;
  userName: string;
  siteName: string | null;
  clockInAt: string;
  clockOutAt: string | null;
  hours: number | null;
  status: '正常' | '稼働中';
  machineId: string | null;
  machineName: string | null;
  workDescription: string | null;
  sessionId?: string;
};

export async function getCalendarDayDetail(
  date: ISODate,
): Promise<{ date: ISODate; sessions: DaySessionDetail[] }> {
  const sessions = await listSessions({ date, pageSize: 100 });
  if (sessions.length === 0) {
    return { date, sessions: [] as DaySessionDetail[] };
  }
  const usersMap = await getCachedUsersMap(usersMapCache, 'default');
  const details: DaySessionDetail[] = [];

  for (const session of sessions) {
    const clockInMs = resolveClockInMs(session);
    if (clockInMs === null) {
      continue;
    }
    const minutes = resolveDurationMinutes(session);
    const clockOutMs = resolveClockOutMs(session, clockInMs);
    const status = normalizeStatus(session);
    const isClosed = status === 'close' && minutes !== null && clockOutMs !== null;
    const userInfo = resolveUserInfo(session, usersMap);
    const siteName = toText(session.siteName) || null;
    const machineId = toText(session.machineId ?? session.machine) || null;
    const machineName = toText(session.machineName ?? session.machine) || null;
    const workDescription = toText(session.workDescription) || null;

    details.push({
      userId: userInfo.recordId ?? (toText(session.user) || null),
      userName: userInfo.name,
      siteName,
      clockInAt: formatJstTime(clockInMs),
      clockOutAt: isClosed && clockOutMs !== null ? formatJstTime(clockOutMs) : null,
      hours: isClosed && minutes !== null ? applyTimeCalcV2FromMinutes(minutes).hours : null,
      status: isClosed ? '正常' : '稼働中',
      machineId,
      machineName: machineName || machineId || null,
      workDescription,
      sessionId: session.sessionId ?? session.id,
    });
  }

  details.sort((a, b) => a.clockInAt.localeCompare(b.clockInAt));

  return { date, sessions: details };
}

export type SessionReportRow = {
  id: string;
  date: string;
  userId: string | null;
  userName: string;
  siteName: string | null;
  machineId: string | null;
  machineName: string | null;
  workDescription: string | null;
  clockInAt: string;
  clockOutAt: string;
  hours: number;
};

export type SessionReportFilters = {
  userExact?: string;
  siteExact?: string;
  userQuery?: string;
  siteQuery?: string;
  machineQuery?: string;
};

function matchesQuery(value: string | null, query?: string): boolean {
  if (!query) {
    return true;
  }
  const trimmed = query.trim();
  if (!trimmed) {
    return true;
  }
  if (!value) {
    return false;
  }
  return value.toLocaleLowerCase('ja').includes(trimmed.toLocaleLowerCase('ja'));
}

export async function getSessionReportRows(
  range: { from: ISODate; to: ISODate },
  filters: SessionReportFilters = {},
): Promise<SessionReportRow[]> {
  const sessions = await listSessions({
    dateFrom: range.from,
    dateTo: range.to,
    status: 'close',
    pageSize: 100,
  });
  if (sessions.length === 0) {
    return [] as SessionReportRow[];
  }

  const usersMap = await getCachedUsersMap(usersMapCache, 'default');
  const userExact = filters.userExact?.trim();
  const siteExact = filters.siteExact?.trim();
  const userQuery = filters.userQuery?.trim();
  const siteQuery = filters.siteQuery?.trim();
  const machineQuery = filters.machineQuery?.trim();

  const rows: SessionReportRow[] = [];

  for (const session of sessions) {
    const date = ensureDate(session);
    if (!date) {
      continue;
    }
    const clockInMs = resolveClockInMs(session);
    const minutes = resolveDurationMinutes(session);
    const clockOutMs = resolveClockOutMs(session, clockInMs);
    if (clockInMs === null || minutes === null || clockOutMs === null) {
      continue;
    }

    const userInfo = resolveUserInfo(session, usersMap);
    const siteName = toText(session.siteName) || null;
    const machineId = toText(session.machineId ?? session.machine) || null;
    const machineName = toText(session.machineName ?? session.machine) || null;
    const machineLabel = machineName || machineId || null;
    const workDescription = toText(session.workDescription) || null;
    const rowUserId = userInfo.recordId ?? (toText(session.user) || null);

    if (userExact && rowUserId !== userExact) {
      continue;
    }
    if (siteExact && siteName !== siteExact) {
      continue;
    }
    if (userQuery && !matchesQuery(userInfo.name, userQuery)) {
      continue;
    }
    if (siteQuery && !matchesQuery(siteName, siteQuery)) {
      continue;
    }
    if (machineQuery && !matchesQuery(machineLabel, machineQuery)) {
      continue;
    }

    const { hours } = applyTimeCalcV2FromMinutes(minutes);

    rows.push({
      id: session.uniqueKey ?? session.id,
      date,
      userId: rowUserId,
      userName: userInfo.name,
      siteName,
      machineId,
      machineName: machineLabel,
      workDescription,
      clockInAt: formatJstIso(clockInMs),
      clockOutAt: formatJstIso(clockOutMs),
      hours,
    });
  }

  return rows.sort((a, b) => {
    return (
      (a.siteName ?? '').localeCompare(b.siteName ?? '', 'ja')
      || a.userName.localeCompare(b.userName, 'ja')
      || (a.machineName ?? '').localeCompare(b.machineName ?? '', 'ja')
      || a.date.localeCompare(b.date)
      || a.clockInAt.localeCompare(b.clockInAt)
    );
  });
}
