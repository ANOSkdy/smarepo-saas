/* eslint-disable @typescript-eslint/no-explicit-any */
// Lightweight Sessions data-access + aggregations (Airtable REST)
// Sole source for dashboard/reports/sites with minimal UI changes.
// Schema (CSV verified): sessionId,user,inLog,outLog,start,end,siteName,workDescription,
// machineId,machine,machineName,autoGenerated,date,durationMin,status,uniqueKey

type ISODate = string; // "YYYY-MM-DD"
type Status = 'open' | 'close' | string;

export type SessionRecord = {
  id: string; // airtable rec id
  sessionId?: string;
  user?: number | string;
  inLog?: string;
  outLog?: string;
  start?: string;
  end?: string;
  siteName?: string;
  workDescription?: string;
  machineId?: number | string;
  machine?: number | string;
  machineName?: string;
  autoGenerated?: any;
  date?: ISODate;
  durationMin?: number;
  status?: Status;
  uniqueKey?: string;
};

export type SessionsQuery = {
  dateFrom?: ISODate;
  dateTo?: ISODate;
  date?: ISODate;
  status?: Status;
  user?: string | number;
  siteName?: string;
  machineId?: string | number;
  workDescription?: string;
  maxRecords?: number;
  pageSize?: number;
  sortBy?: { field: keyof SessionRecord; direction?: 'asc' | 'desc' }[];
  filterFormula?: string;
};

const API = 'https://api.airtable.com/v0';
const API_KEY = process.env.AIRTABLE_API_KEY as string | undefined;
const BASE_ID = process.env.AIRTABLE_BASE_ID as string | undefined;
const TABLE = (process.env.AIRTABLE_TABLE_SESSIONS ?? 'Sessions') as string;

function assertEnv() {
  if (!API_KEY || !BASE_ID || !TABLE) {
    throw new Error('Airtable env missing: require AIRTABLE_API_KEY / AIRTABLE_BASE_ID / AIRTABLE_TABLE_SESSIONS');
  }
}

function esc(v: string) {
  return v.replace(/'/g, "\\'");
}

function buildFilterByFormula(q: SessionsQuery): string | undefined {
  if (q.filterFormula) {
    return q.filterFormula;
  }
  const conds: string[] = [];
  // Prefer simple string/range compares â€“ robust for Date field or "YYYY-MM-DD" string.
  if (q.date) conds.push(`{date}='${esc(q.date)}'`);
  if (q.dateFrom) conds.push(`{date}>='${esc(q.dateFrom)}'`);
  if (q.dateTo) conds.push(`{date}<='${esc(q.dateTo)}'`);
  if (q.status) conds.push(`{status}='${esc(String(q.status))}'`);
  if (q.user !== undefined) conds.push(`{user}='${esc(String(q.user))}'`);
  if (q.siteName) conds.push(`{siteName}='${esc(q.siteName)}'`);
  if (q.machineId !== undefined) conds.push(`{machineId}='${esc(String(q.machineId))}'`);
  if (q.workDescription) conds.push(`{workDescription}='${esc(q.workDescription)}'`);
  if (!conds.length) return undefined;
  return conds.length === 1 ? conds[0] : `AND(${conds.join(',')})`;
}

type AirtableResp = {
  records: { id: string; fields: Record<string, any> }[];
  offset?: string;
};

export async function listSessions(q: SessionsQuery = {}): Promise<SessionRecord[]> {
  assertEnv();
  const params = new URLSearchParams();
  const f = buildFilterByFormula(q);
  if (f) params.set('filterByFormula', f);
  if (q.maxRecords) params.set('maxRecords', String(q.maxRecords));
  if (q.pageSize) params.set('pageSize', String(q.pageSize));
  if (q.sortBy?.length) {
    q.sortBy.forEach((s, i) => {
      params.set(`sort[${i}][field]`, String(s.field));
      if (s.direction) params.set(`sort[${i}][direction]`, s.direction);
    });
  }
  let url = `${API}/${BASE_ID}/${encodeURIComponent(TABLE)}?${params.toString()}`;
  const out: SessionRecord[] = [];
  // simple pagination
  while (true) {
    const res = await fetch(url, {
      headers: { Authorization: `Bearer ${API_KEY}` },
      cache: 'no-store',
    });
    if (!res.ok) {
      const t = await res.text().catch(() => '');
      throw new Error(`Airtable Sessions fetch failed: ${res.status} ${t}`);
    }
    const json: AirtableResp = await res.json();
    for (const r of json.records) {
      out.push({ id: r.id, ...(r.fields as any) });
    }
    if (!json.offset) break;
    url = `${API}/${BASE_ID}/${encodeURIComponent(TABLE)}?${params.toString()}&offset=${json.offset}`;
  }
  return out;
}

// ---------- Aggregations (minimal & UI-friendly) ----------
const minutesToHours = (m?: number) => (typeof m === 'number' ? m / 60 : 0);

export type DashboardAgg = {
  totalHours: number;
  hoursBySite: Record<string, number>;
  hoursByMachine: Record<string, number>;
  hoursByWork: Record<string, number>;
  openCount: number;
};

export async function getDashboardAgg(
  opts: { date?: ISODate; week?: { from: ISODate; to: ISODate }; month?: { from: ISODate; to: ISODate } } = {}
): Promise<DashboardAgg> {
  // prefer "close" sessions for totals; open sessions only for count
  const range = opts.date
    ? { date: opts.date }
    : opts.week
    ? { dateFrom: opts.week.from, dateTo: opts.week.to }
    : opts.month
    ? { dateFrom: opts.month.from, dateTo: opts.month.to }
    : {};
  const [closed, open] = await Promise.all([
    listSessions({ ...range, status: 'close', pageSize: 100 }),
    listSessions({ ...range, status: 'open', pageSize: 100 }),
  ]);
  const totalHours = closed.reduce((sum, record) => sum + minutesToHours(record.durationMin), 0);
  const hoursBy = (key: keyof SessionRecord) =>
    closed.reduce<Record<string, number>>((acc, record) => {
      const k = String((record as any)[key] ?? '');
      if (!k) return acc;
      acc[k] = (acc[k] ?? 0) + minutesToHours(record.durationMin);
      return acc;
    }, {});
  return {
    totalHours,
    hoursBySite: hoursBy('siteName'),
    hoursByMachine: hoursBy('machineId'),
    hoursByWork: hoursBy('workDescription'),
    openCount: open.length,
  };
}

export type GenericGroupAgg = { key: string; hours: number; count: number };

export async function getReportsAgg(opts: {
  from: ISODate;
  to: ISODate;
  user?: string | number;
  siteName?: string;
  machineId?: string | number;
  workDescription?: string;
}): Promise<{
  byDate: GenericGroupAgg[];
  byUser: GenericGroupAgg[];
  bySite: GenericGroupAgg[];
  byMachine: GenericGroupAgg[];
  byWork: GenericGroupAgg[];
}> {
  const rows = await listSessions({
    dateFrom: opts.from,
    dateTo: opts.to,
    status: 'close',
    user: opts.user,
    siteName: opts.siteName,
    machineId: opts.machineId,
    workDescription: opts.workDescription,
    pageSize: 100,
  });
  const sumBy = (key: keyof SessionRecord) => {
    const map = new Map<string, { hours: number; count: number }>();
    for (const record of rows) {
      const groupKey = String((record as any)[key] ?? '');
      const entry = map.get(groupKey) ?? { hours: 0, count: 0 };
      entry.hours += minutesToHours(record.durationMin);
      entry.count += 1;
      map.set(groupKey, entry);
    }
    return [...map.entries()].map(([groupKey, value]) => ({ key: groupKey, hours: value.hours, count: value.count }));
  };
  return {
    byDate: sumBy('date'),
    byUser: sumBy('user'),
    bySite: sumBy('siteName'),
    byMachine: sumBy('machineId'),
    byWork: sumBy('workDescription'),
  };
}

export async function getSiteAgg(opts: { siteName: string; date?: ISODate; from?: ISODate; to?: ISODate }) {
  const rows = await listSessions({
    siteName: opts.siteName,
    ...(opts.date ? { date: opts.date } : {}),
    ...(opts.from || opts.to ? { dateFrom: opts.from, dateTo: opts.to } : {}),
    status: 'close',
    pageSize: 100,
  });
  const totalHours = rows.reduce((sum, record) => sum + minutesToHours(record.durationMin), 0);
  const byUser = rows.reduce<Record<string, number>>((acc, record) => {
    const key = String(record.user ?? '');
    if (!key) return acc;
    acc[key] = (acc[key] ?? 0) + minutesToHours(record.durationMin);
    return acc;
  }, {});
  const byMachine = rows.reduce<Record<string, number>>((acc, record) => {
    const key = String(record.machineId ?? '');
    if (!key) return acc;
    acc[key] = (acc[key] ?? 0) + minutesToHours(record.durationMin);
    return acc;
  }, {});
  const byWork = rows.reduce<Record<string, number>>((acc, record) => {
    const key = String(record.workDescription ?? '');
    if (!key) return acc;
    acc[key] = (acc[key] ?? 0) + minutesToHours(record.durationMin);
    return acc;
  }, {});
  return { totalHours, byUser, byMachine, byWork, rows };
}

// Adapter helpers to keep old prop names if UI expects "workType"
export function mapWorkTypeCompat<T extends { workDescription?: string }>(row: T): T & { workType?: string } {
  return Object.assign({}, row as any, { workType: (row as any).workDescription });
}
