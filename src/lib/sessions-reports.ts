const AIRTABLE_API_KEY = process.env.AIRTABLE_API_KEY;
const AIRTABLE_BASE_ID = process.env.AIRTABLE_BASE_ID;

if (!AIRTABLE_API_KEY) {
  throw new Error('AIRTABLE_API_KEY is not set');
}
if (!AIRTABLE_BASE_ID) {
  throw new Error('AIRTABLE_BASE_ID is not set');
}

const API_BASE = `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}`;
const SESSIONS_TABLE = 'Sessions';
const PAGE_SIZE = 100;
const MAX_RETRY = 3;
const RETRY_DELAY = 500;

const DEFAULT_FIELDS = [
  'date',
  'start',
  'end',
  'durationMin',
  'site',
  'siteName',
  'clientName',
  'client',
  'workDescription',
  'user',
  'userId',
  'userId (from user)',
  'name (from user)',
  'machine',
  'machineId',
  'machineId (from machine)',
  'machineName',
  'machineName (from machine)',
  'status',
  'autoGenerated',
] as const;

type SessionFields = Record<string, unknown>;

type RawAirtableRecord = {
  id: string;
  createdTime: string;
  fields: SessionFields;
};

type AirtableListResponse = {
  records: RawAirtableRecord[];
  offset?: string;
};

export type SessionReportRow = {
  id: string;
  date: string | null;
  year: number | null;
  month: number | null;
  day: number | null;
  start: string | null;
  end: string | null;
  startMs: number | null;
  endMs: number | null;
  durationMin: number | null;
  hours: number | null;
  siteName: string | null;
  siteRecordId: string | null;
  clientName: string | null;
  workDescription: string | null;
  userId: number | null;
  userRecordId: string | null;
  userName: string | null;
  machineId: string | null;
  machineRecordId: string | null;
  machineName: string | null;
  status: string | null;
  autoGenerated: boolean | null;
  isCompleted: boolean;
};

export type SessionReportQuery = {
  siteId?: string | null;
  siteName?: string | null;
  userId?: string | number | null;
  userName?: string | null;
  year?: string | number | null;
  month?: string | number | null;
  day?: string | number | null;
  machineId?: string | number | null;
  workDescription?: string | null;
};

function buildUrl(offset?: string): string {
  const url = new URL(`${API_BASE}/${encodeURIComponent(SESSIONS_TABLE)}`);
  url.searchParams.set('pageSize', String(PAGE_SIZE));
  if (offset) {
    url.searchParams.set('offset', offset);
  }
  for (const field of DEFAULT_FIELDS) {
    url.searchParams.append('fields[]', field);
  }
  return url.toString();
}

async function fetchPage(url: string, attempt = 0): Promise<AirtableListResponse> {
  const headers = { Authorization: `Bearer ${AIRTABLE_API_KEY}` };
  const response = await fetch(url, {
    headers,
    cache: 'no-store',
  });

  if (response.status === 429 || response.status >= 500) {
    if (attempt < MAX_RETRY) {
      const delay = RETRY_DELAY * 2 ** attempt;
      await new Promise((resolve) => setTimeout(resolve, delay));
      return fetchPage(url, attempt + 1);
    }
  }

  if (!response.ok) {
    const body = await response.text();
    throw new Error(`Airtable fetch failed: ${response.status} ${response.statusText} â€“ ${body}`);
  }

  return (await response.json()) as AirtableListResponse;
}

async function fetchAllSessionRecords(): Promise<RawAirtableRecord[]> {
  const records: RawAirtableRecord[] = [];
  let offset: string | undefined;
  do {
    const url = buildUrl(offset);
    const page = await fetchPage(url);
    records.push(...page.records);
    offset = page.offset;
  } while (offset);
  return records;
}

function parseDateParts(dateStr: string | null): { year: number | null; month: number | null; day: number | null } {
  if (!dateStr) {
    return { year: null, month: null, day: null };
  }
  const match = dateStr.match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (!match) {
    return { year: null, month: null, day: null };
  }
  const [, y, m, d] = match;
  const year = Number.parseInt(y, 10);
  const month = Number.parseInt(m, 10);
  const day = Number.parseInt(d, 10);
  return {
    year: Number.isFinite(year) ? year : null,
    month: Number.isFinite(month) ? month : null,
    day: Number.isFinite(day) ? day : null,
  };
}

function asString(value: unknown): string | null {
  if (typeof value === 'string') {
    const trimmed = value.trim();
    return trimmed.length > 0 ? trimmed : null;
  }
  return null;
}

function asBoolean(value: unknown): boolean | null {
  if (typeof value === 'boolean') {
    return value;
  }
  if (value === 'true') {
    return true;
  }
  if (value === 'false') {
    return false;
  }
  return null;
}

function asNumber(value: unknown): number | null {
  if (typeof value === 'number') {
    return Number.isFinite(value) ? value : null;
  }
  if (typeof value === 'string') {
    const parsed = Number(value);
    return Number.isFinite(parsed) ? parsed : null;
  }
  return null;
}

function firstId(value: unknown): string | null {
  if (Array.isArray(value)) {
    for (const entry of value) {
      if (typeof entry === 'string' && entry.trim()) {
        return entry.trim();
      }
    }
    return null;
  }
  if (typeof value === 'string' && value.trim()) {
    return value.trim();
  }
  return null;
}

function toSessionRow(record: RawAirtableRecord): SessionReportRow | null {
  const fields = record.fields ?? {};
  const date = asString(fields.date);
  const { year, month, day } = parseDateParts(date);
  const start = asString(fields.start) ?? asString(fields['start (JST)']);
  const end = asString(fields.end) ?? asString(fields['end (JST)']);
  const durationMin = asNumber(fields.durationMin);
  const hours = durationMin != null ? Math.round((durationMin / 60) * 10) / 10 : null;
  const siteName = asString(fields.siteName) ?? asString(fields['site name']);
  const siteRecordId = firstId(fields.site);
  const clientName =
    asString(fields.clientName) ?? asString(fields.client) ?? asString(fields['client (from site)']);
  const workDescription = asString(fields.workDescription) ?? asString(fields['work description']);

  const rawUserId = asNumber(fields.userId) ?? asNumber(fields['userId (from user)']);
  const userRecordId = firstId(fields.user);
  const userName = asString(fields['name (from user)']) ?? asString(fields.userName) ?? asString(fields.username);

  const machineRecordId = firstId(fields.machine);
  const machineIdValue =
    asString(fields.machineId) ?? asString(fields['machineId (from machine)']) ?? asString(fields.machineid);
  const machineId = machineIdValue ?? (asNumber(fields.machineId) ?? asNumber(fields['machineId (from machine)']))?.toString() ?? null;
  const machineName =
    asString(fields.machineName) ??
    asString(fields['machineName (from machine)']) ??
    asString(fields.machinename);

  const status = asString(fields.status);
  const autoGenerated = asBoolean(fields.autoGenerated);

  const startMs = start ? Date.parse(start) : Number.NaN;
  const endMs = end ? Date.parse(end) : Number.NaN;
  const normalizedStartMs = Number.isFinite(startMs) ? startMs : null;
  const normalizedEndMs = Number.isFinite(endMs) ? endMs : null;
  const isCompleted = Boolean(durationMin && durationMin > 0 && normalizedStartMs !== null && normalizedEndMs !== null);

  return {
    id: record.id,
    date,
    year,
    month,
    day,
    start: start ?? null,
    end: end ?? null,
    startMs: normalizedStartMs,
    endMs: normalizedEndMs,
    durationMin,
    hours,
    siteName,
    siteRecordId,
    clientName,
    workDescription,
    userId: rawUserId,
    userRecordId,
    userName,
    machineId,
    machineRecordId,
    machineName,
    status,
    autoGenerated,
    isCompleted,
  };
}

function normalizeText(value: string | null | undefined): string | null {
  if (!value) {
    return null;
  }
  return value.trim().toLocaleLowerCase('ja');
}

function toNumber(value: string | number | null | undefined): number | null {
  if (typeof value === 'number') {
    return Number.isFinite(value) ? value : null;
  }
  if (typeof value === 'string') {
    const parsed = Number(value);
    return Number.isFinite(parsed) ? parsed : null;
  }
  return null;
}

function matchesQuery(row: SessionReportRow, query?: SessionReportQuery): boolean {
  if (!query) {
    return true;
  }
  if (query.siteId) {
    if (row.siteRecordId !== query.siteId) {
      return false;
    }
  }
  if (query.siteName) {
    const expected = normalizeText(query.siteName);
    const actual = normalizeText(row.siteName);
    if (expected && actual && expected !== actual) {
      return false;
    }
  }
  if (query.userName) {
    const expected = normalizeText(query.userName);
    const actual = normalizeText(row.userName);
    if (expected && actual && expected !== actual) {
      return false;
    }
  }
  if (query.userId != null) {
    const expected = toNumber(query.userId);
    if (expected != null && row.userId !== expected) {
      return false;
    }
  }
  if (query.machineId != null) {
    const expected = normalizeText(String(query.machineId));
    const actual = normalizeText(row.machineId);
    if (expected && actual && expected !== actual) {
      return false;
    }
  }
  if (query.workDescription) {
    const expected = normalizeText(query.workDescription);
    const actual = normalizeText(row.workDescription);
    if (expected && actual && expected !== actual) {
      return false;
    }
  }
  if (query.year != null) {
    const expected = toNumber(query.year);
    if (expected != null && row.year !== expected) {
      return false;
    }
  }
  if (query.month != null) {
    const expected = toNumber(query.month);
    if (expected != null && row.month !== expected) {
      return false;
    }
  }
  if (query.day != null) {
    const expected = toNumber(query.day);
    if (expected != null && row.day !== expected) {
      return false;
    }
  }
  return true;
}

function sortSessions(rows: SessionReportRow[]): SessionReportRow[] {
  return rows.sort((a, b) => {
    const dateA = a.date ?? '';
    const dateB = b.date ?? '';
    if (dateA !== dateB) {
      return dateA.localeCompare(dateB);
    }
    const startA = a.startMs ?? Number.POSITIVE_INFINITY;
    const startB = b.startMs ?? Number.POSITIVE_INFINITY;
    if (startA !== startB) {
      return startA - startB;
    }
    const nameA = a.userName ?? '';
    const nameB = b.userName ?? '';
    const nameCompare = nameA.localeCompare(nameB, 'ja');
    if (nameCompare !== 0) {
      return nameCompare;
    }
    return a.id.localeCompare(b.id);
  });
}

export async function fetchSessionReportRows(query?: SessionReportQuery): Promise<SessionReportRow[]> {
  const records = await fetchAllSessionRecords();
  const rows = records
    .map(toSessionRow)
    .filter((row): row is SessionReportRow => row !== null && row.date !== null)
    .filter((row) => matchesQuery(row, query));
  return sortSessions(rows);
}
